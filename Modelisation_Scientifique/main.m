
clear all;
close all;

%% Import data from text file.
% Script for importing data from the following text file:
%
%    /user/0/.base/lefevreh/home/Documents/Modelisation_Scientifique/Data/synop.2015110912.csv
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2015/11/09 16:53:31

%% Initialize variables.
%filename = '/user/0/.base/lefevreh/home/Documents/Modelisation_Scientifique/Data/synop.2015110912.csv';
filename = fullfile(pwd,'/Data/synop.2015110912.csv');
delimiter = ';';

%% Read columns of data as strings:
% For more information, see the TEXTSCAN documentation.
formatSpec = '%s%*s%*s%*s%*s%*s%*s%s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%s%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter,  'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Convert the contents of columns containing numeric strings to numbers.
% Replace non-numeric strings with NaN.
raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
for col=1:length(dataArray)-1
    raw(1:length(dataArray{col}),col) = dataArray{col};
end
numericData = NaN(size(dataArray{1},1),size(dataArray,2));

for col=[1,2,3]
    % Converts strings in the input cell array to numbers. Replaced non-numeric
    % strings with NaN.
    rawData = dataArray{col};
    for row=1:size(rawData, 1);
        % Create a regular expression to detect and remove non-numeric prefixes and
        % suffixes.
        regexstr = '(?<prefix>.*?)(?<numbers>([-]*(\d+[\,]*)+[\.]{0,1}\d*[eEdD]{0,1}[-+]*\d*[i]{0,1})|([-]*(\d+[\,]*)*[\.]{1,1}\d+[eEdD]{0,1}[-+]*\d*[i]{0,1}))(?<suffix>.*)';
        try
            result = regexp(rawData{row}, regexstr, 'names');
            numbers = result.numbers;
            
            % Detected commas in non-thousand locations.
            invalidThousandsSeparator = false;
            if any(numbers==',');
                thousandsRegExp = '^\d+?(\,\d{3})*\.{0,1}\d*$';
                if isempty(regexp(thousandsRegExp, ',', 'once'));
                    numbers = NaN;
                    invalidThousandsSeparator = true;
                end
            end
            % Convert numeric strings to numbers.
            if ~invalidThousandsSeparator;
                numbers = textscan(strrep(numbers, ',', ''), '%f');
                numericData(row, col) = numbers{1};
                raw{row, col} = numbers{1};
            end
        catch me
        end
    end
end


%% Replace non-numeric cells with NaN
R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),raw); % Find non-numeric cells
raw(R) = {NaN}; % Replace non-numeric cells

%% Allocate imported array to column variable names
numer_sta = cell2mat(raw(:, 1));
t = cell2mat(raw(:, 2));
pres = cell2mat(raw(:, 3));

%% Clear temporary variables
clearvars filename delimiter formatSpec fileID dataArray ans raw col numericData rawData row regexstr result numbers invalidThousandsSeparator thousandsRegExp me R;


%% Extraction des donn�es pour lesquelle on a une coordonn�e g�ographique

% importation de la table de positions geographiques
m = importFile(fullfile(pwd,'Data/postesSynop.csv'));

setId = m(:,1);
indices = [];       % indices des lignes a prendre dans la matrice des donnees

% Extraction des indices n�cessaires
for k=1:size(setId,1)
    id = find(numer_sta == setId(k));
    if (id ~= 0)
        indices = [indices; id];
    end
end

clear setId id

numer_sta = numer_sta(indices);
pres = pres(indices);
t = t(indices);

% latitude = m(indices,3);
% longitude = m(indices,4);
% altitude = m(indices,5);
m = m(indices,:);


%% Interpolation des donn�es sur une grille r�guli�re

nb = size(indices,1);  % Nombre de donnees acquises
N = 10;    % Echantillonnage de la grille
mu = 2;     % Coefficient de l'interpolant

u = linspace(0,1,N);
v = linspace(0,1,N);

minLat = min(m(:,3)); % Latitude
maxLat = max(m(:,3));
minLong = min(m(:,4)); % Longitude
maxLong = max(m(:,4));

interpoleShepard = zeros(N,N);

for i=1:N
    for j=1:N
        X = minLat + u(i) * (maxLat - minLat);
        Y = minLong + v(j) * (maxLong - minLong);
        iii = [X Y];
        
        % Interpolation de la temperature
        eval = 0;
        for k=1:nb
            xk = [m(k,3) m(k,4)];
            
            % Calcul de wk
            s = 0;
            for dj=1:nb
                xl = [m(dj,3) m(dj,4)];
                s = s + (1/(distance(iii, xl) ^ mu));
            end
            wk = (1 / (distance(iii, xk) ^ mu)) * (1 / s);
            
            eval = eval + (wk * t(k));
        end
        
        interpoleShepard(i,j) = eval;
    end
end

clear X Y iii eval xk wk xl s l mu nb;

% Calcul de la colormap
%mini = min(min(interpoleShepard));
%maxi = max(max(interpoleShepard));

% Ensemble de valeurs des isocontours
lambda = [];           % ensemble des isovaleurs a calculer pour le marching square
lambda(1) = 290.0;
square = zeros(N-1,N-1);     % tableau des etats de chaque square

% Parcourt des rectangles pour determiner leur etat
for k=1:length(lambda)
    elem = lambda(k);
    for i=1:(N-1)
        for j=1:(N-1)
            v1 = (interpoleShepard(i,j) >= elem);
            v2 = (interpoleShepard(i,j+1) >= elem);
            v3 = (interpoleShepard(i+1,j+1) >= elem);
            v4 = (interpoleShepard(i+1,j) >= elem);
            bit = v1 + (v2 * 2) + (v3 * 4) + (v4 * 8);
            square(i,j) = bit;
        end
    end
end

clear v1 v2 v3 v4 elem bit;

% Tableau des segments presents dans chaque case de la grille
%   premier entier : nombre de segments
%   ensemble de 4 entiers : un segment
segSquare = zeros(N-1,N-1,9);

dI = (maxLat - minLat) / N;       % pas d'echantillonnage en latitude
dJ = (maxLong - minLong) / N;     % pas d'echantillonnage en longitude

% % Remplissage de la segTable
% for k=1:length(lambda)
%     for i=1:(N-1)
%         for j=1:(N-1)
%             
%             % Valeurs aux quatre coins de la cellule
%             cij =   [minLat + u(i)*(maxLat - minLat), minLong + v(j)*(maxLong - minLong)];
%             cij1 =  [minLat + u(i)*(maxLat - minLat), minLong + v(j+1)*(maxLong - minLong)];
%             ci1j1 = [minLat + u(i+1)*(maxLat - minLat), minLong + v(j+1)*(maxLong - minLong)];
%             ci1j =  [minLat + u(i+1)*(maxLat - minLat), minLong + v(j)*(maxLong - minLong)];
%             
%             switch square(i,j)
%                 case 1
%                     % haut gauche
%                     alpha1 = (lambda(k) - interpoleShepard(i,j)) / dJ;
%                     alpha4 = (lambda(k) - interpoleShepard(i,j)) / dI;
%                     xy1 = (cij * (1-alpha1)) + (cij1 * alpha1);
%                     xy4 = (cij * (1-alpha4)) + (ci1j * alpha4);
%                     segSquare(i,j,:) = [1 xy1(1) xy1(2) xy4(1) xy4(2) 0 0 0 0];
%                 case 2
%                     % haut droite
%                     alpha1 = (lambda(k) - interpoleShepard(i,j)) / dJ;
%                     alpha2 = (lambda(k) - interpoleShepard(i,j+1)) / dI;
%                     xy1 = (cij * (1-alpha1)) + (cij1 * alpha1);
%                     xy2 = (cij1 * (1-alpha2)) + (ci1j1 * alpha2);
%                     segSquare(i,j,:) = [1 xy1(1) xy1(2) xy2(1) xy2(2) 0 0 0 0];
%                 case 3
%                     % horizontal
%                     alpha2 = (lambda(k) - interpoleShepard(i,j+1)) / dI;
%                     alpha4 = (lambda(k) - interpoleShepard(i,j)) / dI;
%                     xy2 = (cij1 * (1-alpha2)) + (ci1j1 * alpha2);
%                     xy4 = (cij * (1-alpha4)) + (ci1j * alpha4);
%                     segSquare(i,j,:) = [1 xy2(1) xy2(2) xy4(1) xy4(2) 0 0 0 0];
%                 case 4
%                     % bas droite
%                     alpha2 = (lambda(k) - interpoleShepard(i,j+1)) / dI;
%                     alpha3 = (lambda(k) - interpoleShepard(i+1,j)) / dJ;
%                     xy2 = (cij1 * (1-alpha2)) + (ci1j1 * alpha2);
%                     xy3 = (ci1j * (1-alpha3)) + (ci1j1 * alpha3);
%                     segSquare(i,j,:) = [1 xy2(1) xy2(2) xy3(1) xy3(2) 0 0 0 0];
%                 case 5
%                     % cas casse co...ille
%                     if (((interpoleShepard(i,j) + interpoleShepard(i,j+1) + interpoleShepard(i+1,j+1) + interpoleShepard(i+1,j))/4) - lambda(k) < 0)
%                         alpha1 = (lambda(k) - interpoleShepard(i,j)) / dJ;
%                         alpha4 = (lambda(k) - interpoleShepard(i,j)) / dI;
%                         xy1 = (cij * (1-alpha1)) + (cij1 * alpha1);
%                         xy4 = (cij * (1-alpha4)) + (ci1j * alpha4);
%                         alpha2 = (lambda(k) - interpoleShepard(i,j+1)) / dI;
%                         alpha3 = (lambda(k) - interpoleShepard(i+1,j)) / dJ;
%                         xy2 = (cij1 * (1-alpha2)) + (ci1j1 * alpha2);
%                         xy3 = (ci1j * (1-alpha3)) + (ci1j1 * alpha3);
%                         segSquare(i,j,:) = [2 xy1(1) xy1(2) xy4(1) xy4(2) xy2(1) xy2(2) xy3(1) xy3(2)];
%                     else
%                         alpha1 = (lambda(k) - interpoleShepard(i,j)) / dJ;
%                         alpha2 = (lambda(k) - interpoleShepard(i,j+1)) / dI;
%                         xy1 = (cij * (1-alpha1)) + (cij1 * alpha1);
%                         xy2 = (cij1 * (1-alpha2)) + (ci1j1 * alpha2);
%                         alpha3 = (lambda(k) - interpoleShepard(i+1,j)) / dJ;
%                         alpha4 = (lambda(k) - interpoleShepard(i,j)) / dI;
%                         xy3 = (ci1j * (1-alpha3)) + (ci1j1 * alpha3);
%                         xy4 = (cij * (1-alpha4)) + (ci1j * alpha4);
%                         segSquare(i,j,:) = [2 xy1(1) xy1(2) xy2(1) xy2(2) xy3(1) xy3(2) xy4(1) xy4(2)];
%                     end
%                 case 6
%                     % vertical
%                     alpha1 = (lambda(k) - interpoleShepard(i,j)) / dJ;
%                     alpha3 = (lambda(k) - interpoleShepard(i+1,j)) / dJ;
%                     xy1 = (cij * (1-alpha1)) + (cij1 * alpha1);
%                     xy3 = (ci1j * (1-alpha3)) + (ci1j1 * alpha3);
%                     segSquare(i,j,:) = [1 xy1(1) xy1(2) xy3(1) xy3(2) 0 0 0 0];
%                 case 7
%                     % bas gauche
%                     alpha3 = (lambda(k) - interpoleShepard(i+1,j)) / dJ;
%                     alpha4 = (lambda(k) - interpoleShepard(i,j)) / dI;
%                     xy3 = (ci1j * (1-alpha3)) + (ci1j1 * alpha3);
%                     xy4 = (cij * (1-alpha4)) + (ci1j * alpha4);
%                     segSquare(i,j,:) = [1 xy3(1) xy3(2) xy4(1) xy4(2) 0 0 0 0];
%                 case 8
%                     % bas gauche
%                     alpha3 = (lambda(k) - interpoleShepard(i+1,j)) / dJ;
%                     alpha4 = (lambda(k) - interpoleShepard(i,j)) / dI;
%                     xy3 = (ci1j * (1-alpha3)) + (ci1j1 * alpha3);
%                     xy4 = (cij * (1-alpha4)) + (ci1j * alpha4);
%                     segSquare(i,j,:) = [1 xy3(1) xy3(2) xy4(1) xy4(2) 0 0 0 0];
%                 case 9
%                     %vertical
%                     alpha1 = (lambda(k) - interpoleShepard(i,j)) / dJ;
%                     alpha3 = (lambda(k) - interpoleShepard(i+1,j)) / dJ;
%                     xy1 = (cij * (1-alpha1)) + (cij1 * alpha1);
%                     xy3 = (ci1j * (1-alpha3)) + (ci1j1 * alpha3);
%                     segSquare(i,j,:) = [1 xy1(1) xy1(2) xy3(1) xy3(2) 0 0 0 0];
%                 case 10
%                     % cas casse co...ille
%                     if (((interpoleShepard(i,j) + interpoleShepard(i,j+1) + interpoleShepard(i+1,j+1) + interpoleShepard(i+1,j))/4) - lambda(k) < 0)
%                         alpha1 = (lambda(k) - interpoleShepard(i,j)) / dJ;
%                         alpha2 = (lambda(k) - interpoleShepard(i,j+1)) / dI;
%                         xy1 = (cij * (1-alpha1)) + (cij1 * alpha1);
%                         xy2 = (cij1 * (1-alpha2)) + (ci1j1 * alpha2);
%                         alpha3 = (lambda(k) - interpoleShepard(i+1,j)) / dJ;
%                         alpha4 = (lambda(k) - interpoleShepard(i,j)) / dI;
%                         xy3 = (ci1j * (1-alpha3)) + (ci1j1 * alpha3);
%                         xy4 = (cij * (1-alpha4)) + (ci1j * alpha4);
%                         segSquare(i,j,:) = [2 xy1(1) xy1(2) xy2(1) xy2(2) xy3(1) xy3(2) xy4(1) xy4(2)];
%                     else
%                         alpha1 = (lambda(k) - interpoleShepard(i,j)) / dJ;
%                         alpha4 = (lambda(k) - interpoleShepard(i,j)) / dI;
%                         xy1 = (cij * (1-alpha1)) + (cij1 * alpha1);
%                         xy4 = (cij * (1-alpha4)) + (ci1j * alpha4);
%                         alpha2 = (lambda(k) - interpoleShepard(i,j+1)) / dI;
%                         alpha3 = (lambda(k) - interpoleShepard(i+1,j)) / dJ;
%                         xy2 = (cij1 * (1-alpha2)) + (ci1j1 * alpha2);
%                         xy3 = (ci1j * (1-alpha3)) + (ci1j1 * alpha3);
%                         segSquare(i,j,:) = [2 xy1(1) xy1(2) xy4(1) xy4(2) xy2(1) xy2(2) xy3(1) xy3(2)];
%                     end
%                 case 11
%                     % bas droite
%                     alpha2 = (lambda(k) - interpoleShepard(i,j+1)) / dI;
%                     alpha3 = (lambda(k) - interpoleShepard(i+1,j)) / dJ;
%                     xy2 = (cij1 * (1-alpha2)) + (ci1j1 * alpha2);
%                     xy3 = (ci1j * (1-alpha3)) + (ci1j1 * alpha3);
%                     segSquare(i,j,:) = [1 xy2(1) xy2(2) xy3(1) xy3(2) 0 0 0 0];
%                 case 12
%                     %horizontal
%                     alpha2 = (lambda(k) - interpoleShepard(i,j+1)) / dI;
%                     alpha4 = (lambda(k) - interpoleShepard(i,j)) / dI;
%                     xy2 = (cij1 * (1-alpha2)) + (ci1j1 * alpha2);
%                     xy4 = (cij * (1-alpha4)) + (ci1j * alpha4);
%                     segSquare(i,j,:) = [1 xy2(1) xy2(2) xy4(1) xy4(2) 0 0 0 0];
%                 case 13
%                     % haut droite
%                     alpha1 = (lambda(k) - interpoleShepard(i,j)) / dJ;
%                     alpha2 = (lambda(k) - interpoleShepard(i,j+1)) / dI;
%                     xy1 = (cij * (1-alpha1)) + (cij1 * alpha1);
%                     xy2 = (cij1 * (1-alpha2)) + (ci1j1 * alpha2);
%                     segSquare(i,j,:) = [1 xy1(1) xy1(2) xy2(1) xy2(2) 0 0 0 0];
%                 case 14
%                     % haut gauche
%                     alpha1 = (lambda(k) - interpoleShepard(i,j)) / dJ;
%                     alpha4 = (lambda(k) - interpoleShepard(i,j)) / dI;
%                     xy1 = (cij * (1-alpha1)) + (cij1 * alpha1);
%                     xy4 = (cij * (1-alpha4)) + (ci1j * alpha4);
%                     segSquare(i,j,:) = [1 xy1(1) xy1(2) xy4(1) xy4(2) 0 0 0 0];
%             end
%         end
%     end
% end

clear i j k xy1 xy2 xy3 xy4 cij cij1 ci1j1 ci1j alpha1 alpha2 alpha3 alpha4;



for i=1:(N-1)
    for j=1:(N-1)
    end
end

clear i j;

%pwr_kml('output_Kelvin', segSquare(:,:,2));


%% 

% Resolution par carre de la grille
reso = 50;

% Creation de la colormap
img = zeros(N*reso, N*reso, 3);
minT = min(min(interpoleShepard))
maxT = max(max(interpoleShepard))

for i=1:(N-1)
    for j=1:(N-1)
        
        for di=1:reso
            for dj=1:reso
                
                dx = di / reso;
                dy = dj / reso;
                v1 = (interpoleShepard(i,j) * (1-dx)) + (interpoleShepard(i,j+1) * dx);
                v2 = (interpoleShepard(i+1,j) * (1-dx)) + (interpoleShepard(i+1,j+1) * dx);
                d = (v1 * (1-dy)) + (v2 * dy);
                
                k = ((i-1) * reso) + di;
                l = ((j-1) * reso) + dj;
                img(k,l,:) = [(d-minT)/(maxT-minT) (d-minT)/(maxT-minT) (d-minT)/(maxT-minT)];
            end
        end
        
    end
end

clear i j di dj k l dx dy d v1 v2;


[r,c] = meshgrid(1:size(img,2),1:size(img,1)); 
figure(1);
 
hold on
imagesc(img);

